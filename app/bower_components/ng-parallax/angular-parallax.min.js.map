{"version":3,"file":"angular-parallax.min.js","sources":["module.js","helper.js","parallax.js"],"names":[],"mappings":"AAAA,QAAA,OAAA,cAAA,WAAA,uBAAA,sBCAA,QAAA,OAAA,wBACA,QAAA,iBACA,WACA,QAAA,GAAA,EAAA,EAAA,EAAA,GACA,MAAA,UAAA,GACA,GAAA,GAAA,IAAA,GAAA,GAAA,EAAA,MACA,OAAA,SAAA,SAAA,IAAA,EAAA,EAAA,EACA,QAAA,SAAA,IAAA,EAAA,EAAA,EACA,GAGA,OACA,eAAA,EACA,WAAA,GAAA,GAAA,IAAA,IAAA,OCbA,QAAA,OAAA,wBAAA,aACA,UAAA,cACA,aAAA,UAAA,YAAA,SAAA,EAAA,EAAA,GAKA,IAAA,GADA,GAFA,EAAA,QAAA,QAAA,eAAA,GACA,EAAA,oDAAA,MAAA,KAEA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,GAAA,SAAA,EAAA,MAAA,EAAA,IAAA,CACA,EAAA,EAAA,EACA,OAOA,GAAA,EAAA,CAIA,GAAA,GAAA,SAAA,GACA,MAAA,GAAA,GAAA,EAAA,EACA,eAAA,KAAA,MAAA,EAAA,GAAA,OAAA,KAAA,MAAA,EAAA,GAAA,SADA,IAIA,EAAA,SAAA,GACA,MAAA,GAAA,SACA,YAAA,QAAA,SAAA,EAAA,UAAA,KAAA,MAAA,EAAA,UAAA,MAAA,EAAA,UAAA,IADA,IAIA,EAAA,SAAA,EAAA,GAGA,GAFA,EAAA,MAAA,GAAA,EAAA,GAAA,EAAA,GACA,EAAA,MAAA,QAAA,EAAA,QACA,EAAA,OACA,IAAA,GAAA,KAAA,GAAA,OACA,EAAA,MAAA,GAAA,EAAA,OAAA,GAKA,QACA,OACA,EAAA,IACA,EAAA,IACA,SAAA,IACA,QAAA,IACA,OAAA,KAEA,KAAA,SAAA,EAAA,GACA,GACA,GADA,EAAA,EAAA,GAEA,GAAA,EAEA,EAAA,WACA,GAAA,GAAA,EAAA,YACA,EAAA,EAAA,uBACA,KACA,GAAA,EACA,QAAA,QAAA,GAAA,GAAA,OAAA,WAGA,GAGA,GAHA,EAAA,EACA,EAAA,GACA,EAAA,EAAA,GAEA,GACA,GAAA,EACA,IACA,EAAA,EAAA,wBAAA,IACA,UACA,EAAA,GAAA,IAAA,KAIA,IAAA,IACA,QAAA,EACA,MAAA,EAAA,KACA,MAAA,EAAA,KAGA,GAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,QAAA,EAAA,OAAA,OAEA,KAAA,GAAA,KAAA,GACA,QAAA,WAAA,EAAA,IACA,EAAA,GAAA,EAAA,GAAA,GACA,EAAA,KACA,EAAA,GAAA,EAAA,GAKA,IAAA,GAAA,QAAA,YAAA,EACA,KAAA,EACA,IAAA,IAAA,GACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,GAAA,CACA,OAKA,IACA,EAAA,EAAA,GACA,EAAA,GAIA,GAAA,GAAA,mBAAA,GAAA,eAAA,UAEA,EAAA,IAAA,WAAA,WACA,EAAA,IAAA,mBAAA","sourcesContent":["angular.module('duParallax', ['duScroll', 'duParallax.directive', 'duParallax.helper']);\n","angular.module('duParallax.helper', []).\nfactory('parallaxHelper',\n  function() {\n    function createAnimator (factor, max, min, offset) {\n      return function(params) {\n        var delta = factor*((offset || 0) + params.elemY);\n        if(angular.isNumber(max) && delta > max) return max;\n        if(angular.isNumber(min) && delta < min) return min;\n        return delta;\n      };\n    }\n    return {\n      createAnimator: createAnimator,\n      background:     createAnimator(-0.3, 150, -30, 50)\n    };\n});\n","angular.module('duParallax.directive', ['duScroll']).\ndirective('duParallax',\n  function($rootScope, $window, $document){\n\n    var test = angular.element('<div></div>')[0];\n    var prefixes = 'transform WebkitTransform MozTransform OTransform'.split(' '); //msTransform\n    var transformProperty;\n    for(var i = 0; i < prefixes.length; i++) {\n      if(test.style[prefixes[i]] !== undefined) {\n        transformProperty = prefixes[i];\n        break;\n      }\n    }\n\n    //Skipping browsers withouth transform-support.\n    //Could do fallback to margin or absolute positioning, but would most likely perform badly\n    //so better UX would be to keep things static.\n    if(!transformProperty){\n      return;\n    }\n\n    var translate3d = function(result){\n      if(!result.x && !result.y) return '';\n      return 'translate3d(' + Math.round(result.x) + 'px, ' + Math.round(result.y) + 'px, 0)';\n    };\n\n    var rotate = function(result) {\n      if(!result.rotation) return '';\n      return ' rotate(' + (angular.isNumber(result.rotation) ? Math.round(result.rotation) + 'deg' : result.rotation) +  ')';\n    };\n\n    var applyProperties = function(result, element) {\n      element.style[transformProperty] = translate3d(result) + rotate(result);\n      element.style.opacity = result.opacity;\n      if(result.custom) {\n        for(var property in result.custom) {\n          element.style[property] = result.custom[property];\n        }\n      }\n    };\n\n    return{\n      scope : {\n        y : '=',\n        x : '=',\n        rotation : '=',\n        opacity : '=',\n        custom : '='\n      },\n      link: function($scope, $element, $attr){\n        var element = $element[0];\n        var currentProperties;\n        var inited = false;\n\n        var onScroll = function(){\n          var scrollY = $document.scrollTop();\n          var rect = element.getBoundingClientRect();\n          if(!inited) {\n            inited = true;\n            angular.element($window).on('load', function init() {\n              //Trigger the onScroll until position stabilizes. Don't know why this is needed.\n              //TODO: Think of more elegant solution.\n              var i = 0;\n              var maxIterations = 10;\n              var currentY = rect.top;\n              var lastY;\n              do {\n                lastY = currentY;\n                onScroll();\n                currentY = element.getBoundingClientRect().top;\n                i++;\n              } while(i < maxIterations && lastY !== currentY);\n            });\n          }\n\n          var param = {\n            scrollY : scrollY,\n            elemX: rect.left,\n            elemY: rect.top\n          };\n\n          var properties = { x : 0, y : 0, rotation : 0, opacity: 1, custom: undefined};\n\n          for(var key in properties){\n            if(angular.isFunction($scope[key])){\n              properties[key] = $scope[key](param);\n            } else if($scope[key]){\n              properties[key] = $scope[key];\n            }\n          }\n\n          //Detect changes, if no changes avoid reflow\n          var hasChange = angular.isUndefined(currentProperties);\n          if(!hasChange) {\n            for(key in properties){\n              if(properties[key] !== currentProperties[key]) {\n                hasChange = true;\n                break;\n              }\n            }\n          }\n\n          if(hasChange) {\n            applyProperties(properties, element);\n            currentProperties = properties;\n          }\n        };\n\n        $document.on('scroll touchmove', onScroll).triggerHandler('scroll');\n\n        $scope.$on('$destroy', function() {\n          $document.off('scroll touchmove', onScroll);\n        });\n      }\n    };\n});\n"],"sourceRoot":"/source/"}